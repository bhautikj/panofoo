<!DOCTYPE html>

<html lang="en">
<head>
<title>Web VR boilerplate (Cardboard and Oculus)</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<style>
body {
  width: 100%;
  height: 100%;
  position: fixed;
  background-color: #000;
  color: #fff;
  margin: 0px;
  padding: 0;
  overflow: hidden;
}
</style>
</head>

<body>
<div id="log"></div>
</body>


<!--
  three.js 3d library
  -->
<script src="js-ext/three.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="js-ext/VRControls.js"></script>
<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="js/VRViewerEffect.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="js-ext/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="js-ext/webvr-manager.js"></script>


<script>
/*
 * Debug parameters.
 */

// Enable distortion everywhere.
//WEBVR_FORCE_DISTORTION = true;
// Override the distortion background color.
//WEBVR_BACKGROUND_COLOR = new THREE.Vector4(1, 0, 0, 1);
// Change the tracking prediction mode; normally 2 but its laggy as all hell
// on normal phones so wind it back to 0.
WEBVR_PREDICTION_MODE = 0;
// In prediction mode, change how far into the future to predict.
//WEBVR_PREDICTION_TIME_MS = 100;
</script>

<script>
/**
 * util funcs
 */
 Math.radians = function(degrees) {
  return degrees * Math.PI / 180;
};
 
// Converts from radians to degrees.
Math.degrees = function(radians) {
  return radians * 180 / Math.PI;
};
</script>
<script>
//Setup three.js WebGL renderer
var renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);

// Append the canvas element created by the renderer to document body element.
document.body.appendChild(renderer.domElement);

// Create a three.js scene.
var scene = new THREE.Scene();

// Create a three.js camera.
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.3, 10000);

// Apply VR headset positional data to camera.
var controls = new THREE.VRControls(camera);

// Apply VR stereo rendering to renderer.
var effect = new THREE.VRViewerEffect(renderer, 0);
effect.setSize(window.innerWidth, window.innerHeight);

var textureDescription = new TextureDescription();
textureDescription.textureSource = "stereograph_a.jpg";
textureDescription.metaSource = "https://www.flickr.com/photos/127906254@N06/17787986691/";
textureDescription.isStereo = false;
textureDescription.sphereFOV = new THREE.Vector2(90, 90);
// in degrees
textureDescription.sphereCentre = new THREE.Vector2(180.0, 90.0);
//image size: 2048,996
//0,0
textureDescription.U = new THREE.Vector2(0.0, 0.0);
//1010,996
textureDescription.V = new THREE.Vector2(0.493, 1.0);
//1018,0
//textureDescription.rightTopLeft = new THREE.Vector2(0.497, 0.0);
//2028,996
//textureDescription.rightBottomRight = new THREE.Vector2(0.990, 1.0);

// textureDescription.textureSource = "stereograph_b.jpg";
// textureDescription.metaSource = "https://www.flickr.com/photos/library_of_congress/3253742804/";
// textureDescription.isStereo = false;
// textureDescription.leftTopLeft = new THREE.Vector2(0.0, 0.0);
// textureDescription.leftBottomRight = new THREE.Vector2(1.0, 1.0);
// textureDescription.rightTopLeft = new THREE.Vector2(0.0, 0.0);
// textureDescription.rightBottomRight = new THREE.Vector2(1.0, 1.0);

effect.setStereographicProjection(textureDescription);

// Create a VR manager helper to enter and exit VR mode.
var manager = new WebVRManager(renderer, effect, {hideButton: false});

//----------


var boxgeom = new THREE.BoxGeometry(0.5, 0.5, 0.5);
var boxmat = new THREE.MeshNormalMaterial();
var cube = new THREE.Mesh(boxgeom, boxmat);

// Position cube mesh
cube.position.z = -1;

// Add cube mesh to your three.js scene
scene.add(cube);

//override render function
manager.render = function(scene, camera, timestamp) {
  if (this.isVRMode()) {
    this.distorter.preRender();
    this.effect.render(scene, camera);
    this.distorter.postRender();
  } else {
    // Scene may be an array of two scenes, one for each eye.
    if (scene instanceof Array) {
      this.effect.render(scene[0], camera);
    } else {
      this.effect.render(scene, camera);
    }
  }
  if (this.input && this.input.setAnimationFrameTime) {
    this.input.setAnimationFrameTime(timestamp);
  }
};

// Request animation frame loop function
function animate(timestamp) {
  // Apply rotation to cube mesh
   cube.rotation.y += 0.01;

  // Update VR headset position and apply to camera.
  controls.update();
  
  manager.renderer.autoClear = false;
  manager.renderer.clear();

  if (manager.isVRMode()){ 
    effect.setRenderMode(2);
  } else {
    effect.setRenderMode(0);
  }
  
  manager.render(scene, camera, timestamp);

  //   uniforms.iGlobalTime.value += 0.001;

  requestAnimationFrame(animate);
}

// Kick off animation loop
animate();

// Reset the position sensor when 'z' pressed.
function onKey(event) {
  if (event.keyCode == 90) { // z
    controls.resetSensor();
  }
};

window.addEventListener('keydown', onKey, true);

// Handle window resizes
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  effect.setSize(window.innerWidth, window.innerHeight);
}

window.addEventListener('resize', onWindowResize, false);

</script>

</html>
