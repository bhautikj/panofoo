<!DOCTYPE html>

<html lang="en">
<head>
<title>Web VR boilerplate (Cardboard and Oculus)</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<style>
body {
  width: 100%;
  height: 100%;
  position: fixed;
  background-color: #000;
  color: #fff;
  margin: 0px;
  padding: 0;
  overflow: hidden;
}
</style>
</head>

<body>
<div id="log"></div>
</body>

<!-- 
  shader scripts 
  -->
<script id="vertexShader" type="x-shader/x-vertex">

  void main() {
    gl_Position = vec4( position, 1.0 );
  }

</script>

<script id="fragmentShader" type="x-shader/x-fragment">

  uniform vec2 iResolution;
  uniform sampler2D texture1;
  uniform vec2 uvOfs;
  uniform vec2 fov;
   
  void main(void) {
      //uv is between 0 and 1
      vec2 uv = gl_FragCoord.xy/iResolution.xy;

      uv.x = mod(0.5*uv.x + uvOfs.x, 1.0);
      uv.y = 0.5 * uv.y;
      
      // texture coords are between 0 and 0.5; scale appropriately
      float textureScaleScalar = 1.0;
      uv = textureScaleScalar*uv;
      
      gl_FragColor = texture2D(texture1, uv);
  }

</script>

<!--
  three.js 3d library
  -->
<script src="js-ext/three.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="js-ext/VRControls.js"></script>
e
<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="js/VRViewerEffect.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="js-ext/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="js-ext/webvr-manager.js"></script>




<script>
/*
 * Debug parameters.
 */

// Enable distortion everywhere.
//WEBVR_FORCE_DISTORTION = true;
// Override the distortion background color.
//WEBVR_BACKGROUND_COLOR = new THREE.Vector4(1, 0, 0, 1);
// Change the tracking prediction mode.
//WEBVR_PREDICTION_MODE = 2;
// In prediction mode, change how far into the future to predict.
//WEBVR_PREDICTION_TIME_MS = 100;
</script>

<script>
/**
 * util funcs
 */
 Math.radians = function(degrees) {
  return degrees * Math.PI / 180;
};
 
// Converts from radians to degrees.
Math.degrees = function(radians) {
  return radians * 180 / Math.PI;
};
</script>
<script>
//Setup three.js WebGL renderer
var renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);

// Append the canvas element created by the renderer to document body element.
document.body.appendChild(renderer.domElement);

// Create a three.js scene.
var scene = new THREE.Scene();

// Create a three.js camera.
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.3, 10000);

// Apply VR headset positional data to camera.
var controls = new THREE.VRControls(camera);

// Apply VR stereo rendering to renderer.
var effect = new THREE.VRViewerEffect(renderer, 'classic');
effect.setSize(window.innerWidth, window.innerHeight);

// Create a VR manager helper to enter and exit VR mode.
var manager = new WebVRManager(renderer, effect, {hideButton: false});

//----------
imgTex = THREE.ImageUtils.loadTexture( "panotest.jpg" );
imgTex.wrapS = THREE.RepeatWrapping;
imgTex.wrapT = THREE.RepeatWrapping;

uniforms = {
  texture1: { type: "t", value: imgTex },
  iResolution: { type: "v2", value: new THREE.Vector2() },
  uvOfs: { type: "v2", value: new THREE.Vector2() },
  fov: { type: "v2", value: new THREE.Vector2() }
};

function fovyFromFovx(ix, iy, fovx) {
  var d = ix/(2.0*Math.tan(0.5*fovx));
  var fovy = 2*Math.atan(0.5*iy/d);
  return fovy;
}

function bj_addBackgroundQuad(scene, uniforms) {
  
  var material = new THREE.ShaderMaterial( {
    uniforms: uniforms,
    vertexShader: document.getElementById( 'vertexShader' ).textContent,
    fragmentShader: document.getElementById( 'fragmentShader' ).textContent

  } );
  uniforms.fov.value.x=Math.radians(60);
  uniforms.uvOfs.value.x = 0.0;
  uniforms.uvOfs.value.y = 0.0;

  uniforms.iResolution.value.x = window.innerWidth;
  uniforms.iResolution.value.y = window.innerHeight;
  uniforms.fov.value.y=fovyFromFovx(uniforms.iResolution.value.x, 
                                    uniforms.iResolution.value.y, 
                                    uniforms.fov.value.x);

  var plane = new THREE.PlaneBufferGeometry( window.innerWidth, window.innerHeight );
  quad = new THREE.Mesh( plane, material );
  quad.material.depthTest = false;
  quad.material.depthWrite = false;
  quad.position.z = -10;
  scene.add( quad );
}

bj_addBackgroundQuad(scene, uniforms);
        
//----------


var boxgeom = new THREE.BoxGeometry(0.5, 0.5, 0.5);
var boxmat = new THREE.MeshNormalMaterial();
var cube = new THREE.Mesh(boxgeom, boxmat);

// Position cube mesh
cube.position.z = -1;

// Add cube mesh to your three.js scene
scene.add(cube);

// Request animation frame loop function
function animate(timestamp) {
  // Apply rotation to cube mesh
   cube.rotation.y += 0.01;

  // Update VR headset position and apply to camera.
  controls.update();
  
  manager.renderer.autoClear = false;
  manager.renderer.clear();

  //render dummy scene
  manager.render(scene, camera, timestamp);

  // Render the scene through the manager.
  manager.render(scene, camera, timestamp);

//   uniforms.iGlobalTime.value += 0.001;

  requestAnimationFrame(animate);

  
  cameraLook = camera.getWorldDirection();
  anglePitch = Math.atan2(cameraLook.x,cameraLook.z);
  angleYaw = Math.asin(cameraLook.y);
  uniforms.uvOfs.value.x = anglePitch/(-2.0*3.142);
  uniforms.uvOfs.value.y = angleYaw/3.142
  document.getElementById("log").innerHTML = uniforms.uvOfs.value.x + "," + uniforms.uvOfs.value.y;

}

// Kick off animation loop
animate();

// Reset the position sensor when 'z' pressed.
function onKey(event) {
  if (event.keyCode == 90) { // z
    controls.resetSensor();
  }
};

window.addEventListener('keydown', onKey, true);

function bj_resizeQuad(uniforms) {
  uniforms.iResolution.value.x = window.innerWidth;
  uniforms.iResolution.value.y = window.innerHeight;
  uniforms.fov.value.y=fovyFromFovx(uniforms.fov.value.x);
}

// Handle window resizes
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  effect.setSize(window.innerWidth, window.innerHeight);

  bj_resizeQuad(uniforms);
}

window.addEventListener('resize', onWindowResize, false);

</script>

</html>
